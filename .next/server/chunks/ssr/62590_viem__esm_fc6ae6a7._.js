module.exports=[643115,a=>{"use strict";function b(a){return"string"==typeof a?{address:a,type:"json-rpc"}:a}a.s(["parseAccount",()=>b])},737023,a=>{"use strict";var b=a.i(746061);class c extends b.BaseError{constructor({address:a}){super(`Address "${a}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."],name:"InvalidAddressError"})}}a.s(["InvalidAddressError",()=>c])},368463,943416,a=>{"use strict";var b=a.i(236436),c=a.i(865340);let d=BigInt(0),e=BigInt(1),f=BigInt(2),g=BigInt(7),h=BigInt(256),i=BigInt(113),j=[],k=[],l=[];for(let a=0,b=e,c=1,m=0;a<24;a++){[c,m]=[m,(2*c+3*m)%5],j.push(2*(5*m+c)),k.push((a+1)*(a+2)/2%64);let n=d;for(let a=0;a<7;a++)(b=(b<<e^(b>>g)*i)%h)&f&&(n^=e<<(e<<BigInt(a))-e);l.push(n)}let m=(0,b.split)(l,!0),n=m[0],o=m[1],p=(a,c,d)=>d>32?(0,b.rotlBH)(a,c,d):(0,b.rotlSH)(a,c,d),q=(a,c,d)=>d>32?(0,b.rotlBL)(a,c,d):(0,b.rotlSL)(a,c,d);class r extends c.Hash{constructor(a,b,d,e=!1,f=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=a,this.suffix=b,this.outputLen=d,this.enableXOF=e,this.rounds=f,(0,c.anumber)(d),!(0<a&&a<200))throw Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=(0,c.u32)(this.state)}clone(){return this._cloneInto()}keccak(){(0,c.swap32IfBE)(this.state32),function(a,b=24){let d=new Uint32Array(10);for(let c=24-b;c<24;c++){for(let b=0;b<10;b++)d[b]=a[b]^a[b+10]^a[b+20]^a[b+30]^a[b+40];for(let b=0;b<10;b+=2){let c=(b+8)%10,e=(b+2)%10,f=d[e],g=d[e+1],h=p(f,g,1)^d[c],i=q(f,g,1)^d[c+1];for(let c=0;c<50;c+=10)a[b+c]^=h,a[b+c+1]^=i}let b=a[2],e=a[3];for(let c=0;c<24;c++){let d=k[c],f=p(b,e,d),g=q(b,e,d),h=j[c];b=a[h],e=a[h+1],a[h]=f,a[h+1]=g}for(let b=0;b<50;b+=10){for(let c=0;c<10;c++)d[c]=a[b+c];for(let c=0;c<10;c++)a[b+c]^=~d[(c+2)%10]&d[(c+4)%10]}a[0]^=n[c],a[1]^=o[c]}(0,c.clean)(d)}(this.state32,this.rounds),(0,c.swap32IfBE)(this.state32),this.posOut=0,this.pos=0}update(a){(0,c.aexists)(this),a=(0,c.toBytes)(a),(0,c.abytes)(a);let{blockLen:b,state:d}=this,e=a.length;for(let c=0;c<e;){let f=Math.min(b-this.pos,e-c);for(let b=0;b<f;b++)d[this.pos++]^=a[c++];this.pos===b&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:a,suffix:b,pos:c,blockLen:d}=this;a[c]^=b,(128&b)!=0&&c===d-1&&this.keccak(),a[d-1]^=128,this.keccak()}writeInto(a){(0,c.aexists)(this,!1),(0,c.abytes)(a),this.finish();let b=this.state,{blockLen:d}=this;for(let c=0,e=a.length;c<e;){this.posOut>=d&&this.keccak();let f=Math.min(d-this.posOut,e-c);a.set(b.subarray(this.posOut,this.posOut+f),c),this.posOut+=f,c+=f}return a}xofInto(a){if(!this.enableXOF)throw Error("XOF is not possible for this instance");return this.writeInto(a)}xof(a){return(0,c.anumber)(a),this.xofInto(new Uint8Array(a))}digestInto(a){if((0,c.aoutput)(a,this),this.finished)throw Error("digest() was already called");return this.writeInto(a),this.destroy(),a}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,(0,c.clean)(this.state)}_cloneInto(a){let{blockLen:b,suffix:c,outputLen:d,rounds:e,enableXOF:f}=this;return a||(a=new r(b,c,d,f,e)),a.state32.set(this.state32),a.pos=this.pos,a.posOut=this.posOut,a.finished=this.finished,a.rounds=e,a.suffix=c,a.outputLen=d,a.enableXOF=f,a.destroyed=this.destroyed,a}}let s=(0,c.createHasher)(()=>new r(136,1,32));a.s(["keccak_256",0,s],943416);var t=a.i(919674),u=a.i(380455),v=a.i(172639);function w(a,b){let c=s((0,t.isHex)(a,{strict:!1})?(0,u.toBytes)(a):a);return"bytes"===(b||"hex")?c:(0,v.toHex)(c)}a.s(["keccak256",()=>w],368463)},793990,a=>{"use strict";a.s(["isAddress",()=>f]);var b=a.i(133915),c=a.i(161643);let d=/^0x[a-fA-F0-9]{40}$/,e=new b.LruMap(8192);function f(a,b){let{strict:f=!0}=b??{},g=`${a}.${f}`;if(e.has(g))return e.get(g);let h=!!d.test(a)&&(a.toLowerCase()===a||!f||(0,c.checksumAddress)(a)===a);return e.set(g,h),h}},161643,a=>{"use strict";a.s(["checksumAddress",()=>h,"getAddress",()=>i]);var b=a.i(737023),c=a.i(380455),d=a.i(368463),e=a.i(133915),f=a.i(793990);let g=new e.LruMap(8192);function h(a,b){if(g.has(`${a}.${b}`))return g.get(`${a}.${b}`);let e=b?`${b}${a.toLowerCase()}`:a.substring(2).toLowerCase(),f=(0,d.keccak256)((0,c.stringToBytes)(e),"bytes"),h=(b?e.substring(`${b}0x`.length):e).split("");for(let a=0;a<40;a+=2)f[a>>1]>>4>=8&&h[a]&&(h[a]=h[a].toUpperCase()),(15&f[a>>1])>=8&&h[a+1]&&(h[a+1]=h[a+1].toUpperCase());let i=`0x${h.join("")}`;return g.set(`${a}.${b}`,i),i}function i(a,c){if(!(0,f.isAddress)(a,{strict:!1}))throw new b.InvalidAddressError({address:a});return h(a,c)}},337750,a=>{"use strict";function b(a,b){return({exclude:c,format:d})=>({exclude:c,format:(a,e)=>{let f=b(a,e);if(c)for(let a of c)delete f[a];return{...f,...d(a,e)}},type:a})}a.s(["defineFormatter",()=>b])},48362,a=>{"use strict";function b(a){return"string"==typeof a[0]?c(a):function(a){let b=0;for(let c of a)b+=c.length;let c=new Uint8Array(b),d=0;for(let b of a)c.set(b,d),d+=b.length;return c}(a)}function c(a){return`0x${a.reduce((a,b)=>a+b.replace("0x",""),"")}`}a.s(["concat",()=>b,"concatHex",()=>c])},908834,83798,a=>{"use strict";var b=a.i(746061);class c extends b.BaseError{constructor({offset:a}){super(`Offset \`${a}\` cannot be negative.`,{name:"NegativeOffsetError"})}}class d extends b.BaseError{constructor({length:a,position:b}){super(`Position \`${b}\` is out of bounds (\`0 < position < ${a}\`).`,{name:"PositionOutOfBoundsError"})}}class e extends b.BaseError{constructor({count:a,limit:b}){super(`Recursive read limit of \`${b}\` exceeded (recursive read count: \`${a}\`).`,{name:"RecursiveReadLimitExceededError"})}}a.s(["NegativeOffsetError",()=>c,"PositionOutOfBoundsError",()=>d,"RecursiveReadLimitExceededError",()=>e],83798);let f={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:1/0,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new e({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(a){if(a<0||a>this.bytes.length-1)throw new d({length:this.bytes.length,position:a})},decrementPosition(a){if(a<0)throw new c({offset:a});let b=this.position-a;this.assertPosition(b),this.position=b},getReadCount(a){return this.positionReadCount.get(a||this.position)||0},incrementPosition(a){if(a<0)throw new c({offset:a});let b=this.position+a;this.assertPosition(b),this.position=b},inspectByte(a){let b=a??this.position;return this.assertPosition(b),this.bytes[b]},inspectBytes(a,b){let c=b??this.position;return this.assertPosition(c+a-1),this.bytes.subarray(c,c+a)},inspectUint8(a){let b=a??this.position;return this.assertPosition(b),this.bytes[b]},inspectUint16(a){let b=a??this.position;return this.assertPosition(b+1),this.dataView.getUint16(b)},inspectUint24(a){let b=a??this.position;return this.assertPosition(b+2),(this.dataView.getUint16(b)<<8)+this.dataView.getUint8(b+2)},inspectUint32(a){let b=a??this.position;return this.assertPosition(b+3),this.dataView.getUint32(b)},pushByte(a){this.assertPosition(this.position),this.bytes[this.position]=a,this.position++},pushBytes(a){this.assertPosition(this.position+a.length-1),this.bytes.set(a,this.position),this.position+=a.length},pushUint8(a){this.assertPosition(this.position),this.bytes[this.position]=a,this.position++},pushUint16(a){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,a),this.position+=2},pushUint24(a){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,a>>8),this.dataView.setUint8(this.position+2,255&a),this.position+=3},pushUint32(a){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,a),this.position+=4},readByte(){this.assertReadLimit(),this._touch();let a=this.inspectByte();return this.position++,a},readBytes(a,b){this.assertReadLimit(),this._touch();let c=this.inspectBytes(a);return this.position+=b??a,c},readUint8(){this.assertReadLimit(),this._touch();let a=this.inspectUint8();return this.position+=1,a},readUint16(){this.assertReadLimit(),this._touch();let a=this.inspectUint16();return this.position+=2,a},readUint24(){this.assertReadLimit(),this._touch();let a=this.inspectUint24();return this.position+=3,a},readUint32(){this.assertReadLimit(),this._touch();let a=this.inspectUint32();return this.position+=4,a},get remaining(){return this.bytes.length-this.position},setPosition(a){let b=this.position;return this.assertPosition(a),this.position=a,()=>this.position=b},_touch(){if(this.recursiveReadLimit===1/0)return;let a=this.getReadCount();this.positionReadCount.set(this.position,a+1),a>0&&this.recursiveReadCount++}};function g(a,{recursiveReadLimit:b=8192}={}){let c=Object.create(f);return c.bytes=a,c.dataView=new DataView(a.buffer??a,a.byteOffset,a.byteLength),c.positionReadCount=new Map,c.recursiveReadLimit=b,c}a.s(["createCursor",()=>g],908834)},209261,157708,a=>{"use strict";var b=a.i(430159),c=a.i(507284);function d(a,e="wei"){return(0,c.formatUnits)(a,b.etherUnits[e])}a.s(["formatEther",()=>d],157708);var e=a.i(194621),f=a.i(746061);function g(a){let b=Object.entries(a).map(([a,b])=>void 0===b||!1===b?null:[a,b]).filter(Boolean),c=b.reduce((a,[b])=>Math.max(a,b.length),0);return b.map(([a,b])=>`  ${`${a}:`.padEnd(c+1)}  ${b}`).join("\n")}f.BaseError;class h extends f.BaseError{constructor({v:a}){super(`Invalid \`v\` value "${a}". Expected 27 or 28.`,{name:"InvalidLegacyVError"})}}class i extends f.BaseError{constructor({transaction:a}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",g(a),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- an EIP-7702 Transaction with `authorizationList`, or","- a Legacy Transaction with `gasPrice`"],name:"InvalidSerializableTransactionError"})}}f.BaseError,f.BaseError;class j extends f.BaseError{constructor({storageKey:a}){super(`Size for storage key "${a}" is invalid. Expected 32 bytes. Got ${Math.floor((a.length-2)/2)} bytes.`,{name:"InvalidStorageKeySizeError"})}}class k extends f.BaseError{constructor(a,{account:b,docsPath:c,chain:f,data:h,gas:i,gasPrice:j,maxFeePerGas:k,maxPriorityFeePerGas:l,nonce:m,to:n,value:o}){super(a.shortMessage,{cause:a,docsPath:c,metaMessages:[...a.metaMessages?[...a.metaMessages," "]:[],"Request Arguments:",g({chain:f&&`${f?.name} (id: ${f?.id})`,from:b?.address,to:n,value:void 0!==o&&`${d(o)} ${f?.nativeCurrency?.symbol||"ETH"}`,data:h,gas:i,gasPrice:void 0!==j&&`${(0,e.formatGwei)(j)} gwei`,maxFeePerGas:void 0!==k&&`${(0,e.formatGwei)(k)} gwei`,maxPriorityFeePerGas:void 0!==l&&`${(0,e.formatGwei)(l)} gwei`,nonce:m})].filter(Boolean),name:"TransactionExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=a}}class l extends f.BaseError{constructor({blockHash:a,blockNumber:b,blockTag:c,hash:d,index:e}){let f="Transaction";c&&void 0!==e&&(f=`Transaction at block time "${c}" at index "${e}"`),a&&void 0!==e&&(f=`Transaction at block hash "${a}" at index "${e}"`),b&&void 0!==e&&(f=`Transaction at block number "${b}" at index "${e}"`),d&&(f=`Transaction with hash "${d}"`),super(`${f} could not be found.`,{name:"TransactionNotFoundError"})}}class m extends f.BaseError{constructor({hash:a}){super(`Transaction receipt with hash "${a}" could not be found. The Transaction may not be processed on a block yet.`,{name:"TransactionReceiptNotFoundError"})}}class n extends f.BaseError{constructor({receipt:a}){super(`Transaction with hash "${a.transactionHash}" reverted.`,{metaMessages:['The receipt marked the transaction as "reverted". This could mean that the function on the contract you are trying to call threw an error.'," ","You can attempt to extract the revert reason by:","- calling the `simulateContract` or `simulateCalls` Action with the `abi` and `functionName` of the contract","- using the `call` Action with raw `data`"],name:"TransactionReceiptRevertedError"}),Object.defineProperty(this,"receipt",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.receipt=a}}class o extends f.BaseError{constructor({hash:a}){super(`Timed out while waiting for transaction with hash "${a}" to be confirmed.`,{name:"WaitForTransactionReceiptTimeoutError"})}}a.s(["InvalidLegacyVError",()=>h,"InvalidSerializableTransactionError",()=>i,"InvalidStorageKeySizeError",()=>j,"TransactionExecutionError",()=>k,"TransactionNotFoundError",()=>l,"TransactionReceiptNotFoundError",()=>m,"TransactionReceiptRevertedError",()=>n,"WaitForTransactionReceiptTimeoutError",()=>o,"prettyPrint",()=>g],209261)},751407,a=>{"use strict";a.s(["maxUint256",0,2n**256n-1n])},774671,a=>{"use strict";var b=a.i(746061);class c extends b.BaseError{constructor({blockNumber:a,chain:b,contract:c}){super(`Chain "${b.name}" does not support contract "${c.name}".`,{metaMessages:["This could be due to any of the following:",...a&&c.blockCreated&&c.blockCreated>a?[`- The contract "${c.name}" was not deployed until block ${c.blockCreated} (current block ${a}).`]:[`- The chain does not have the contract "${c.name}" configured.`]],name:"ChainDoesNotSupportContract"})}}class d extends b.BaseError{constructor({chain:a,currentChainId:b}){super(`The current chain of the wallet (id: ${b}) does not match the target chain for the transaction (id: ${a.id} – ${a.name}).`,{metaMessages:[`Current Chain ID:  ${b}`,`Expected Chain ID: ${a.id} – ${a.name}`],name:"ChainMismatchError"})}}class e extends b.BaseError{constructor(){super("No chain was provided to the request.\nPlease provide a chain with the `chain` argument on the Action, or by supplying a `chain` to WalletClient.",{name:"ChainNotFoundError"})}}class f extends b.BaseError{constructor(){super("No chain was provided to the Client.",{name:"ClientChainNotConfiguredError"})}}class g extends b.BaseError{constructor({chainId:a}){super("number"==typeof a?`Chain ID "${a}" is invalid.`:"Chain ID is invalid.",{name:"InvalidChainIdError"})}}a.s(["ChainDoesNotSupportContract",()=>c,"ChainMismatchError",()=>d,"ChainNotFoundError",()=>e,"ClientChainNotConfiguredError",()=>f,"InvalidChainIdError",()=>g])},623436,a=>{"use strict";var b=a.i(872074),c=a.i(919674),d=a.i(573701);function e(a,b,d,{strict:f}={}){return(0,c.isHex)(a,{strict:!1})?i(a,b,d,{strict:f}):h(a,b,d,{strict:f})}function f(a,c){if("number"==typeof c&&c>0&&c>(0,d.size)(a)-1)throw new b.SliceOffsetOutOfBoundsError({offset:c,position:"start",size:(0,d.size)(a)})}function g(a,c,e){if("number"==typeof c&&"number"==typeof e&&(0,d.size)(a)!==e-c)throw new b.SliceOffsetOutOfBoundsError({offset:e,position:"end",size:(0,d.size)(a)})}function h(a,b,c,{strict:d}={}){f(a,b);let e=a.slice(b,c);return d&&g(e,b,c),e}function i(a,b,c,{strict:d}={}){f(a,b);let e=`0x${a.replace("0x","").slice((b??0)*2,(c??a.length)*2)}`;return d&&g(e,b,c),e}a.s(["slice",()=>e,"sliceBytes",()=>h,"sliceHex",()=>i])}];

//# sourceMappingURL=62590_viem__esm_fc6ae6a7._.js.map