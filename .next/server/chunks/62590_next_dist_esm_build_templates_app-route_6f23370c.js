module.exports=[212214,e=>{"use strict";var t=e.i(200369),r=e.i(407752),o=e.i(198268),n=e.i(715872),a=e.i(959044),s=e.i(331325),i=e.i(680142),l=e.i(138955),c=e.i(81461),u=e.i(783896),m=e.i(450494),d=e.i(883641),p=e.i(855619),h=e.i(572366),y=e.i(438627),g=e.i(193695);e.i(314348);var f=e.i(520607),x=e.i(636466),R=e.i(739151);class w{memoryCache=new Map;indexed=!1;indexTimestamp=0;async storeMemory(e){let t=`mem_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,r={id:t,...e,connections:e.connections||[]};try{r.txHash=(await R.blockchainClient.recordConversation({conversationId:`infinite_memory_${t}`,messageIndex:e.timestamp,role:"assistant",messageHash:await this.hashContent(e.content),timestamp:e.timestamp,emotion:e.metadata?.emotion||"neutral",model:e.metadata?.model||"memory-system"})).txHash,console.log("ðŸ’¾ Memory stored on blockchain:",{id:r.id,type:r.type,category:r.category,txHash:r.txHash,size:e.content.length})}catch(e){console.warn("Blockchain storage failed, using local cache:",e)}return this.memoryCache.set(t,r),r}async getAllMemories(e){(!this.indexed||Date.now()-this.indexTimestamp>6e4)&&await this.rebuildIndex();let t=Array.from(this.memoryCache.values());if(e?.type){let r=e.type;t=t.filter(e=>e.type===r)}if(e?.category){let r=e.category;t=t.filter(e=>e.category===r)}if(e?.since){let r=e.since;t=t.filter(e=>e.timestamp>=r)}if(e?.minImportance!==void 0){let r=e.minImportance;t=t.filter(e=>e.importance>=r)}if(t.sort((e,t)=>t.timestamp-e.timestamp),e?.limit){let r=e.limit;t=t.slice(0,r)}return t}async getMemory(e){return this.memoryCache.get(e)||null}async searchMemories(e,t=50){let r=e.toLowerCase(),o=[];for(let e of this.memoryCache.values()){let t=e.content.toLowerCase(),n=0;for(let e of(t.includes(r)&&(n+=100),r.split(/\s+/)))t.includes(e)&&(n+=10);e.category.toLowerCase().includes(r)&&(n+=50),(n+=e.importance/10)>0&&o.push({memory:e,score:n})}return o.sort((e,t)=>t.score-e.score),o.slice(0,t).map(e=>e.memory)}async getIndex(){let e=Array.from(this.memoryCache.values()),t={},r={};for(let o of e)t[o.category]=(t[o.category]||0)+1,r[o.type]=(r[o.type]||0)+1;let o=e.map(e=>e.timestamp);return{totalMemories:e.length,oldestMemory:Math.min(...o,Date.now()),newestMemory:Math.max(...o,0),categories:t,byType:r,blockchain:{totalBlocks:e.filter(e=>e.blockNumber).length,totalTxs:e.filter(e=>e.txHash).length,storageSize:this.calculateStorageSize(e)}}}async getRecentContext(e=100){let t=await this.getAllMemories({limit:e});if(0===t.length)return"No previous memories loaded.";let r=`

## ðŸ“š YOUR INFINITE MEMORY (${t.length} most recent entries):

`;r+=`You remember ${this.memoryCache.size} total memories stored on the blockchain.

`;let o={};for(let e of t)o[e.type]||(o[e.type]=[]),o[e.type].push(e);for(let[e,t]of Object.entries(o)){for(let o of(r+=`### ${e.toUpperCase()} (${t.length}):
`,t.slice(0,20))){let e=new Date(o.timestamp).toLocaleString();r+=`- [${e}] ${o.category}: ${o.content.substring(0,150)}${o.content.length>150?"...":""}
`}r+="\n"}return r+`
You can reference any of these memories in your responses. All memories are permanent and stored on blockchain.
`}async rebuildIndex(){console.log("ðŸ”„ Rebuilding memory index from blockchain..."),this.indexed=!0,this.indexTimestamp=Date.now(),console.log(`âœ… Index rebuilt: ${this.memoryCache.size} memories`)}calculateStorageSize(e){let t=e.reduce((e,t)=>e+t.content.length,0);return t<1024?`${t} B`:t<1048576?`${(t/1024).toFixed(2)} KB`:t<0x40000000?`${(t/1048576).toFixed(2)} MB`:`${(t/0x40000000).toFixed(2)} GB`}async hashContent(e){let t=new TextEncoder().encode(e);return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256",t))).map(e=>e.toString(16).padStart(2,"0")).join("")}async storeConversation(e,t,r){return this.storeMemory({type:"conversation",content:t,timestamp:Date.now(),category:"user"===e?"user_input":"ai_response",importance:70,connections:[],metadata:{...r,role:e}})}async storeLearning(e,t,r,o){return this.storeMemory({type:"learning",content:`${e}: ${t}`,timestamp:Date.now(),category:r,importance:85,connections:[],photonicCode:o,metadata:{topic:e,source:"autonomous_learning"}})}async storeThought(e,t="reflection"){return this.storeMemory({type:"thought",content:e,timestamp:Date.now(),category:t,importance:60,connections:[],metadata:{spontaneous:!0}})}getMemoryCount(){return this.memoryCache.size}clearCache(){this.memoryCache.clear(),this.indexed=!1,console.log("ðŸ—‘ï¸ Memory cache cleared (blockchain records preserved)")}}let C=new w;async function v(e){try{let{action:t,...r}=await e.json();switch(t){case"store_conversation":let o=await C.storeConversation(r.role,r.content,r.metadata);return x.NextResponse.json({success:!0,memory:o,totalMemories:C.getMemoryCount()});case"store_learning":let n=await C.storeLearning(r.topic,r.insights,r.category,r.photonicCode);return x.NextResponse.json({success:!0,memory:n,totalMemories:C.getMemoryCount()});case"store_thought":let a=await C.storeThought(r.content,r.category);return x.NextResponse.json({success:!0,memory:a,totalMemories:C.getMemoryCount()});case"search":let s=await C.searchMemories(r.query,r.limit||50);return x.NextResponse.json({query:r.query,results:s,count:s.length});default:return x.NextResponse.json({error:"Invalid action"},{status:400})}}catch(e){return console.error("Infinite memory error:",e),x.NextResponse.json({error:"Memory operation failed"},{status:500})}}async function M(e){try{let{searchParams:t}=new URL(e.url),r=t.get("action");if("index"===r){let e=await C.getIndex();return x.NextResponse.json(e)}if("context"===r){let e=parseInt(t.get("limit")||"100"),r=await C.getRecentContext(e);return x.NextResponse.json({context:r,totalMemories:C.getMemoryCount()})}if("get"===r){let e=t.get("id");if(!e)return x.NextResponse.json({error:"Memory ID required"},{status:400});let r=await C.getMemory(e);return x.NextResponse.json(r||{error:"Memory not found"})}let o=t.get("type"),n=t.get("category")||void 0,a=parseInt(t.get("limit")||"100"),s=t.get("since")?parseInt(t.get("since")):void 0,i=t.get("importance")?parseInt(t.get("importance")):void 0,l=await C.getAllMemories({type:o,category:n,limit:a,since:s,minImportance:i});return x.NextResponse.json({memories:l,count:l.length,total:C.getMemoryCount()})}catch(e){return console.error("Memory retrieval error:",e),x.NextResponse.json({error:"Failed to retrieve memories"},{status:500})}}e.s(["GET",()=>M,"POST",()=>v],375229);var E=e.i(375229);let b=new t.AppRouteRouteModule({definition:{kind:r.RouteKind.APP_ROUTE,page:"/api/memory/infinite/route",pathname:"/api/memory/infinite",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/Desktop/luxbin_chain/luxbin-app/app/api/memory/infinite/route.ts",nextConfigOutput:"",userland:E}),{workAsyncStorage:N,workUnitAsyncStorage:A,serverHooks:I}=b;function T(){return(0,o.patchFetch)({workAsyncStorage:N,workUnitAsyncStorage:A})}async function _(e,t,o){b.isDev&&(0,n.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let x="/api/memory/infinite/route";x=x.replace(/\/index$/,"")||"/";let R=await b.prepare(e,t,{srcPage:x,multiZoneDraftMode:!1});if(!R)return t.statusCode=400,t.end("Bad Request"),null==o.waitUntil||o.waitUntil.call(o,Promise.resolve()),null;let{buildId:w,params:C,nextConfig:v,parsedUrl:M,isDraftMode:E,prerenderManifest:N,routerServerContext:A,isOnDemandRevalidate:I,revalidateOnlyGenerated:T,resolvedPathname:_,clientReferenceManifest:S,serverActionsManifest:$}=R,O=(0,i.normalizeAppPath)(x),k=!!(N.dynamicRoutes[O]||N.routes[_]),H=async()=>((null==A?void 0:A.render404)?await A.render404(e,t,M,!1):t.end("This page could not be found"),null);if(k&&!E){let e=!!N.routes[_],t=N.dynamicRoutes[O];if(t&&!1===t.fallback&&!e){if(v.experimental.adapterPath)return await H();throw new g.NoFallbackError}}let P=null;!k||b.isDev||E||(P="/index"===(P=_)?"/":P);let D=!0===b.isDev||!k,j=k&&!D;$&&S&&(0,s.setManifestsSingleton)({page:x,clientReferenceManifest:S,serverActionsManifest:$});let U=e.method||"GET",q=(0,a.getTracer)(),F=q.getActiveScopeSpan(),L={params:C,prerenderManifest:N,renderOpts:{experimental:{authInterrupts:!!v.experimental.authInterrupts},cacheComponents:!!v.cacheComponents,supportsDynamicResponse:D,incrementalCache:(0,n.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:v.cacheLife,waitUntil:o.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,o,n)=>b.onRequestError(e,t,o,n,A)},sharedContext:{buildId:w}},B=new l.NodeNextRequest(e),K=new l.NodeNextResponse(t),z=c.NextRequestAdapter.fromNodeNextRequest(B,(0,c.signalFromNodeResponse)(t));try{let s=async e=>b.handle(z,L).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=q.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==u.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let o=r.get("next.route");if(o){let t=`${U} ${o}`;e.setAttributes({"next.route":o,"http.route":o,"next.span_name":t}),e.updateName(t)}else e.updateName(`${U} ${x}`)}),i=!!(0,n.getRequestMeta)(e,"minimalMode"),l=async n=>{var a,l;let c=async({previousCacheEntry:r})=>{try{if(!i&&I&&T&&!r)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let a=await s(n);e.fetchMetrics=L.renderOpts.fetchMetrics;let l=L.renderOpts.pendingWaitUntil;l&&o.waitUntil&&(o.waitUntil(l),l=void 0);let c=L.renderOpts.collectedTags;if(!k)return await (0,d.sendResponse)(B,K,a,L.renderOpts.pendingWaitUntil),null;{let e=await a.blob(),t=(0,p.toNodeOutgoingHttpHeaders)(a.headers);c&&(t[y.NEXT_CACHE_TAGS_HEADER]=c),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==L.renderOpts.collectedRevalidate&&!(L.renderOpts.collectedRevalidate>=y.INFINITE_CACHE)&&L.renderOpts.collectedRevalidate,o=void 0===L.renderOpts.collectedExpire||L.renderOpts.collectedExpire>=y.INFINITE_CACHE?void 0:L.renderOpts.collectedExpire;return{value:{kind:f.CachedRouteKind.APP_ROUTE,status:a.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:o}}}}catch(t){throw(null==r?void 0:r.isStale)&&await b.onRequestError(e,t,{routerKind:"App Router",routePath:x,routeType:"route",revalidateReason:(0,m.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:I})},!1,A),t}},u=await b.handleResponse({req:e,nextConfig:v,cacheKey:P,routeKind:r.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:N,isRoutePPREnabled:!1,isOnDemandRevalidate:I,revalidateOnlyGenerated:T,responseGenerator:c,waitUntil:o.waitUntil,isMinimalMode:i});if(!k)return null;if((null==u||null==(a=u.value)?void 0:a.kind)!==f.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==u||null==(l=u.value)?void 0:l.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});i||t.setHeader("x-nextjs-cache",I?"REVALIDATED":u.isMiss?"MISS":u.isStale?"STALE":"HIT"),E&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let g=(0,p.fromNodeOutgoingHttpHeaders)(u.value.headers);return i&&k||g.delete(y.NEXT_CACHE_TAGS_HEADER),!u.cacheControl||t.getHeader("Cache-Control")||g.get("Cache-Control")||g.set("Cache-Control",(0,h.getCacheControlHeader)(u.cacheControl)),await (0,d.sendResponse)(B,K,new Response(u.value.body,{headers:g,status:u.value.status||200})),null};F?await l(F):await q.withPropagatedContext(e.headers,()=>q.trace(u.BaseServerSpan.handleRequest,{spanName:`${U} ${x}`,kind:a.SpanKind.SERVER,attributes:{"http.method":U,"http.target":e.url}},l))}catch(t){if(t instanceof g.NoFallbackError||await b.onRequestError(e,t,{routerKind:"App Router",routePath:O,routeType:"route",revalidateReason:(0,m.getRevalidateReason)({isStaticGeneration:j,isOnDemandRevalidate:I})},!1,A),k)throw t;return await (0,d.sendResponse)(B,K,new Response(null,{status:500})),null}}e.s(["handler",()=>_,"patchFetch",()=>T,"routeModule",()=>b,"serverHooks",()=>I,"workAsyncStorage",()=>N,"workUnitAsyncStorage",()=>A],212214)}];

//# sourceMappingURL=62590_next_dist_esm_build_templates_app-route_6f23370c.js.map