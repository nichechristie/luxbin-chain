<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LUXBIN Multi-Wave Translator</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            background: rgba(255, 255, 255, 0.1);
            padding: 30px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #FF6B35, #7C3AED, #00D4AA, #FFD700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            opacity: 0.9;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        .input-section {
            margin: 20px 0;
        }
        textarea {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            resize: vertical;
            min-height: 100px;
        }
        button {
            background: linear-gradient(45deg, #FF6B35, #7C3AED);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: transform 0.2s;
            margin: 10px 5px;
        }
        button:hover {
            transform: scale(1.05);
        }
        .wave-toggle {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        .wave-toggle button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #00D4AA;
        }
        .wave-toggle button.active {
            background: #00D4AA;
            color: #333;
        }
        .process-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
            gap: 20px;
        }
        .step {
            flex: 1;
            min-width: 200px;
            text-align: center;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border: 2px solid transparent;
            transition: border-color 0.3s;
        }
        .step.active {
            border-color: #00D4AA;
            background: rgba(255, 255, 255, 0.2);
        }
        .step h3 {
            margin-top: 0;
            color: #FF6B35;
        }
        .output {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }
        .wave-visualization {
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            height: 200px;
            position: relative;
            overflow: hidden;
        }
        .wave-canvas {
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #000011, #000033);
        }
        .color-display {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
            max-height: 150px;
            overflow-y: auto;
        }
        .color-box {
            width: 30px;
            height: 30px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            display: inline-block;
            transition: transform 0.2s;
        }
        .color-box:hover {
            transform: scale(1.2);
        }
        .wavelength, .frequency {
            font-size: 12px;
            text-align: center;
            margin-top: 5px;
            opacity: 0.8;
        }
        .superposition-info {
            background: rgba(255, 212, 170, 0.2);
            border: 1px solid #FFD700;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        .superposition-info h4 {
            color: #FFD700;
            margin-top: 0;
        }
        .footer {
            text-align: center;
            margin-top: 30px;
            opacity: 0.7;
        }
        .footer a {
            color: #00D4AA;
            text-decoration: none;
        }
        .footer a:hover {
            text-decoration: underline;
        }
        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 10px 0;
        }
        .audio-controls button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #FFD700;
        }
        .audio-controls button.active {
            background: #FFD700;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåàüéµ LUXBIN Multi-Wave Translator</h1>
        <p class="subtitle">Advanced photonic communication with acoustic superposition and multi-wavelength encoding</p>

        <div class="input-section">
            <label for="input-text"><strong>Enter Natural Language:</strong></label>
            <textarea id="input-text" placeholder="Type your message here... e.g., 'Hello Quantum World'"></textarea>
        </div>

        <div class="wave-toggle">
            <button onclick="setWaveMode('photonic')" class="active" id="photonic-btn">üåà Photonic Only</button>
            <button onclick="setWaveMode('acoustic')" id="acoustic-btn">üéµ Acoustic Waves</button>
            <button onclick="setWaveMode('radio')" id="radio-btn">üìª Radio Waves</button>
            <button onclick="setWaveMode('superposition')" id="superposition-btn">‚öõÔ∏è Quantum Superposition</button>
        </div>

        <div style="text-align: center;">
            <button onclick="translate()">üîÑ Translate to LUXBIN</button>
            <button onclick="generateLightShow()">‚ú® Generate Light Show</button>
            <button onclick="clearAll()">üóëÔ∏è Clear</button>
        </div>

        <div class="process-flow">
            <div class="step" id="step1">
                <h3>üìù Natural Language</h3>
                <div class="output" id="natural-lang">Your input text will appear here</div>
            </div>
            <div class="step" id="step2">
                <h3>üìö LUXBIN Dictionary</h3>
                <div class="output" id="luxbin-dict">LUXBIN characters will appear here</div>
            </div>
            <div class="step" id="step3">
                <h3>üî¢ Binary Code</h3>
                <div class="output" id="binary-code">Binary representation will appear here</div>
            </div>
            <div class="step" id="step4">
                <h3>üåà Multi-Wave Encoding</h3>
                <div id="color-display" class="color-display"></div>
                <div id="wavelength-info" class="wavelength"></div>
                <div id="frequency-info" class="frequency"></div>
                <div class="audio-controls" id="audio-controls" style="display: none;">
                    <button onclick="playAudio()">‚ñ∂Ô∏è Play Audio</button>
                    <button onclick="stopAudio()">‚èπÔ∏è Stop</button>
                </div>
            </div>
        </div>

        <div class="wave-visualization">
            <canvas id="wave-canvas" class="wave-canvas"></canvas>
        </div>

        <div class="superposition-info" id="superposition-info" style="display: none;">
            <h4>‚öõÔ∏è Quantum Superposition Analysis</h4>
            <p id="superposition-details">Three wavelengths combined with matched amplitudes create quantum-like interference patterns for enhanced data density.</p>
        </div>

        <div class="footer">
            <p>Multi-modal communication: Photonic + Acoustic + Radio waves with quantum superposition | Powered by <a href="https://github.com/mermaidnicheboutique-code/luxbin-light-language">LUXBIN Light Language</a></p>
        </div>
    </div>

    <script>
        let currentMode = 'photonic';
        let audioContext = null;
        let oscillators = [];
        let canvas, ctx;
        let animationId = null;

        // LUXBIN Character Set (simplified)
        const LUXBIN_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 .,!?;:-()[]{}@#$%^&*+=_~`<>\"'|\\";

        // Initialize canvas
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('wave-canvas');
            if (!canvas) {
                console.error('Canvas element not found!');
                return;
            }
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Could not get canvas context!');
                return;
            }
            console.log('Canvas initialized successfully');
            document.getElementById('input-text').value = 'HELLO QUANTUM';
            translate();
        });

        function setWaveMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.wave-toggle button').forEach(btn => btn.classList.remove('active'));
            document.getElementById(mode + '-btn').classList.add('active');

            const audioControls = document.getElementById('audio-controls');
            const superpositionInfo = document.getElementById('superposition-info');

            if (mode === 'acoustic' || mode === 'radio' || mode === 'superposition') {
                audioControls.style.display = 'flex';
                if (mode === 'superposition') {
                    superpositionInfo.style.display = 'block';
                } else {
                    superpositionInfo.style.display = 'none';
                }
            } else {
                audioControls.style.display = 'none';
                superpositionInfo.style.display = 'none';
            }
        }

        // Color mapping for demonstration (HSL to RGB conversion)
        function hslToRgb(h, s, l) {
            h /= 360;
            s /= 100;
            l /= 100;
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
        }

        // Convert text to binary
        function textToBinary(text) {
            return text.split('').map(char => {
                return char.charCodeAt(0).toString(2).padStart(8, '0');
            }).join(' ');
        }

        // Convert binary to LUXBIN characters (simplified mapping)
        function binaryToLuxbin(binary) {
            const cleanBinary = binary.replace(/\s/g, '');
            let result = '';
            for (let i = 0; i < cleanBinary.length; i += 6) {
                const chunk = cleanBinary.substr(i, 6).padEnd(6, '0');
                const index = parseInt(chunk, 2) % LUXBIN_ALPHABET.length;
                result += LUXBIN_ALPHABET[index];
            }
            return result;
        }

        // Convert LUXBIN to multi-wave encoding
        function luxbinToWaves(luxbin) {
            const colors = [];
            const wavelengths = [];
            const frequencies = [];
            const amplitudes = [];

            for (let i = 0; i < luxbin.length; i += 3) {
                const char1 = luxbin[i] || 'A';
                const char2 = luxbin[i + 1] || 'A';
                const char3 = luxbin[i + 2] || 'A';

                const index1 = LUXBIN_ALPHABET.indexOf(char1.toUpperCase());
                const index2 = LUXBIN_ALPHABET.indexOf(char2.toUpperCase());
                const index3 = LUXBIN_ALPHABET.indexOf(char3.toUpperCase());

                // Primary wavelength (visible light)
                const hue = (index1 / LUXBIN_ALPHABET.length) * 360;
                const rgb = hslToRgb(hue, 80, 60);
                colors.push(`rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
                wavelengths.push(`${Math.round(400 + (hue / 360) * 300)}nm`);

                // Secondary frequencies based on mode
                if (currentMode === 'acoustic') {
                    // Audio frequencies (20Hz - 20kHz)
                    const freq1 = 200 + (index1 / LUXBIN_ALPHABET.length) * 19980;
                    const freq2 = 200 + (index2 / LUXBIN_ALPHABET.length) * 19980;
                    const freq3 = 200 + (index3 / LUXBIN_ALPHABET.length) * 19980;
                    frequencies.push(`${Math.round(freq1)}Hz`);
                    amplitudes.push([0.3, 0.3, 0.3]); // Equal amplitudes
                } else if (currentMode === 'radio') {
                    // Radio frequencies (1MHz - 100MHz)
                    const freq1 = 1000000 + (index1 / LUXBIN_ALPHABET.length) * 99000000;
                    const freq2 = 1000000 + (index2 / LUXBIN_ALPHABET.length) * 99000000;
                    const freq3 = 1000000 + (index3 / LUXBIN_ALPHABET.length) * 99000000;
                    frequencies.push(`${(freq1/1000000).toFixed(1)}MHz`);
                    amplitudes.push([0.3, 0.3, 0.3]);
                } else if (currentMode === 'superposition') {
                    // Superposition: matched amplitudes for interference
                    const baseFreq = 440 + (index1 / LUXBIN_ALPHABET.length) * 880; // Musical scale
                    const freq1 = baseFreq;
                    const freq2 = baseFreq * 1.25; // Perfect fifth
                    const freq3 = baseFreq * 1.5;  // Perfect octave
                    frequencies.push(`${Math.round(freq1)}Hz | ${Math.round(freq2)}Hz | ${Math.round(freq3)}Hz`);
                    amplitudes.push([0.4, 0.4, 0.4]); // Matched amplitudes for superposition
                }
            }

            return { colors, wavelengths, frequencies, amplitudes };
        }

        function drawWaves(colors, amplitudes) {
            if (!canvas || !ctx) {
                console.error('Canvas or context not available for drawing');
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const time = Date.now() * 0.005;
            const centerY = canvas.height / 2;

            // Draw multiple waves
            colors.forEach((color, index) => {
                if (index >= 3) return; // Limit to 3 waves for visualization

                const amp = amplitudes[index] || [0.3, 0.3, 0.3];
                const yOffset = (index - 1) * 40; // Stack waves vertically

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let x = 0; x < canvas.width; x++) {
                    let y = 0;

                    if (currentMode === 'superposition' && index === 0) {
                        // Draw superposition of three waves
                        y += Math.sin(x * 0.02 + time) * amp[0] * 30;
                        y += Math.sin(x * 0.025 + time * 1.25) * amp[1] * 30;
                        y += Math.sin(x * 0.03 + time * 1.5) * amp[2] * 30;
                    } else {
                        // Single wave
                        y = Math.sin(x * 0.02 + time + index * Math.PI / 3) * amp[0] * 30;
                    }

                    if (x === 0) {
                        ctx.moveTo(x, centerY + y + yOffset);
                    } else {
                        ctx.lineTo(x, centerY + y + yOffset);
                    }
                }

                ctx.stroke();
            });
        }

        function translate() {
            const input = document.getElementById('input-text').value;
            if (!input.trim()) {
                alert('Please enter some text to translate!');
                return;
            }

            // Reset active steps
            document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));

            // Step 1: Natural Language
            document.getElementById('natural-lang').textContent = input;
            document.getElementById('step1').classList.add('active');

            setTimeout(() => {
                // Step 2: Binary Code
                const binary = textToBinary(input);
                document.getElementById('binary-code').textContent = binary;
                document.getElementById('step2').classList.remove('active');
                document.getElementById('step3').classList.add('active');

                setTimeout(() => {
                    // Step 3: LUXBIN Dictionary
                    const luxbin = binaryToLuxbin(binary);
                    document.getElementById('luxbin-dict').textContent = luxbin;
                    document.getElementById('step3').classList.remove('active');
                    document.getElementById('step4').classList.add('active');

                    setTimeout(() => {
                        // Step 4: Multi-Wave Encoding
                        const { colors, wavelengths, frequencies, amplitudes } = luxbinToWaves(luxbin);

                        const colorDisplay = document.getElementById('color-display');
                        colorDisplay.innerHTML = '';
                        colors.forEach(color => {
                            const box = document.createElement('div');
                            box.className = 'color-box';
                            box.style.backgroundColor = color;
                            colorDisplay.appendChild(box);
                        });

                        document.getElementById('wavelength-info').textContent =
                            `Wavelengths: ${wavelengths.slice(0, 8).join(', ')}${wavelengths.length > 8 ? '...' : ''}`;

                        if (frequencies.length > 0) {
                            document.getElementById('frequency-info').textContent =
                                `Frequencies: ${frequencies.slice(0, 3).join(', ')}${frequencies.length > 3 ? '...' : ''}`;
                        }

                        // Start wave animation
                        if (animationId) cancelAnimationFrame(animationId);
                        function animate() {
                            drawWaves(colors, amplitudes);
                            animationId = requestAnimationFrame(animate);
                        }
                        animate();

                    }, 1000);
                }, 1000);
            }, 1000);
        }

        function playAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            stopAudio(); // Stop any existing audio

            const input = document.getElementById('input-text').value;
            const binary = textToBinary(input);
            const luxbin = binaryToLuxbin(binary);

            const { frequencies, amplitudes } = luxbinToWaves(luxbin);

            frequencies.forEach((freqStr, index) => {
                if (currentMode === 'superposition' && index === 0) {
                    // Create superposition of three oscillators
                    const baseFreq = parseFloat(freqStr.split(' | ')[0]);
                    const freqs = [
                        baseFreq,
                        baseFreq * 1.25,
                        baseFreq * 1.5
                    ];

                    freqs.forEach((freq, i) => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                        oscillator.type = 'sine';

                        gainNode.gain.setValueAtTime(amplitudes[index][i] || 0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 2);

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 2);

                        oscillators.push(oscillator);
                    });
                } else {
                    const freq = parseFloat(freqStr.split('Hz')[0]);
                    if (freq && freq > 0) {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                        oscillator.type = 'sine';

                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.start();
                        oscillator.stop(audioContext.currentTime + 1);

                        oscillators.push(oscillator);
                    }
                }
            });
        }

        function stopAudio() {
            oscillators.forEach(osc => {
                try {
                    osc.stop();
                } catch (e) {
                    // Already stopped
                }
            });
            oscillators = [];
        }

        function generateLightShow() {
            console.log('Generate Light Show called');
            const input = document.getElementById('input-text').value;
            if (!input.trim()) {
                alert('Please enter some text first!');
                return;
            }

            // Get the wave data
            const binary = textToBinary(input);
            const luxbin = binaryToLuxbin(binary);
            const { colors, wavelengths, frequencies, amplitudes } = luxbinToWaves(luxbin);
            console.log('Wave data:', { colors, wavelengths, frequencies, amplitudes });

            // Start intense light show animation
            if (animationId) {
                cancelAnimationFrame(animationId);
                console.log('Cancelled previous animation');
            }

            let time = 0;
            function animate() {
                time += 0.02;
                drawWaves(colors, amplitudes);

                // Add pulsing effect for light show
                const intensity = 0.5 + 0.5 * Math.sin(time * 2);
                const waveViz = document.querySelector('.wave-visualization');
                if (waveViz) {
                    waveViz.style.opacity = 0.8 + intensity * 0.2;
                }

                animationId = requestAnimationFrame(animate);
            }
            animate();
            console.log('Animation started');

            // Flash the step indicator
            const step4 = document.getElementById('step4');
            if (step4) {
                step4.classList.add('active');
                setTimeout(() => step4.classList.add('active'), 100);
                setTimeout(() => step4.classList.remove('active'), 200);
                setTimeout(() => step4.classList.add('active'), 300);
            }

            // Auto-play audio if in audio mode
            if (currentMode !== 'photonic') {
                setTimeout(() => {
                    console.log('Auto-playing audio');
                    playAudio();
                }, 500);
            }
        }

        function clearAll() {
            document.getElementById('input-text').value = '';
            document.getElementById('natural-lang').textContent = 'Your input text will appear here';
            document.getElementById('luxbin-dict').textContent = 'LUXBIN characters will appear here';
            document.getElementById('binary-code').textContent = 'Binary representation will appear here';
            document.getElementById('color-display').innerHTML = '';
            document.getElementById('wavelength-info').textContent = '';
            document.getElementById('frequency-info').textContent = '';
            document.querySelectorAll('.step').forEach(step => step.classList.remove('active'));

            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }

            if (ctx) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            stopAudio();
        }
    </script>
</body>
</html>